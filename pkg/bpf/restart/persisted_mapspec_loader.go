//go:build !enhanced
// +build !enhanced

// Code generated by hack/gen_bpf_specs.go; DO NOT EDIT.

package restart

import (
	"fmt"

	"github.com/cilium/ebpf"

	dualengine "kmesh.net/kmesh/bpf/kmesh/bpf2go/dualengine"
	general "kmesh.net/kmesh/bpf/kmesh/bpf2go/general"
	kernelnative_normal "kmesh.net/kmesh/bpf/kmesh/bpf2go/kernelnative/normal"
	"kmesh.net/kmesh/daemon/options"
	helper "kmesh.net/kmesh/pkg/utils"
)

// Auto-generated: keeps in sync with //go:generate bpf2go lines.
func LoadCompileTimeSpecs(config *options.BpfConfig) (map[string]map[string]*ebpf.MapSpec, error) {
	specs := make(map[string]map[string]*ebpf.MapSpec)

	if config.KernelNativeEnabled() {
		// Symbol KmeshCgroupSock has both normal and compat variants.
		if helper.KernelVersionLowerThan5_13() {
			if coll, err := kernelnative_normal.LoadKmeshCgroupSockCompat(); err != nil {
				return nil, fmt.Errorf("load Compat KmeshCgroupSockCompat spec: %w", err)
			} else {
				specs["KmeshCgroupSockCompat"] = coll.Maps
			}
		} else {
			if coll, err := kernelnative_normal.LoadKmeshCgroupSock(); err != nil {
				return nil, fmt.Errorf("load KmeshCgroupSock spec: %w", err)
			} else {
				specs["KmeshCgroupSock"] = coll.Maps
			}
		}
		// Symbol KmeshSockops has both normal and compat variants.
		if helper.KernelVersionLowerThan5_13() {
			if coll, err := kernelnative_normal.LoadKmeshSockopsCompat(); err != nil {
				return nil, fmt.Errorf("load Compat KmeshSockopsCompat spec: %w", err)
			} else {
				specs["KmeshSockopsCompat"] = coll.Maps
			}
		} else {
			if coll, err := kernelnative_normal.LoadKmeshSockops(); err != nil {
				return nil, fmt.Errorf("load KmeshSockops spec: %w", err)
			} else {
				specs["KmeshSockops"] = coll.Maps
			}
		}
	} else if config.DualEngineEnabled() {
		// Symbol KmeshCgroupSkb has both normal and compat variants (dualengine).
		if helper.KernelVersionLowerThan5_13() {
			if coll, err := dualengine.LoadKmeshCgroupSkbCompat(); err != nil {
				return nil, fmt.Errorf("load Compat KmeshCgroupSkbCompat spec: %w", err)
			} else {
				specs["KmeshCgroupSkbCompat"] = coll.Maps
			}
		} else {
			if coll, err := dualengine.LoadKmeshCgroupSkb(); err != nil {
				return nil, fmt.Errorf("load KmeshCgroupSkb spec: %w", err)
			} else {
				specs["KmeshCgroupSkb"] = coll.Maps
			}
		}
		// Symbol KmeshCgroupSockWorkload has both normal and compat variants (dualengine).
		if helper.KernelVersionLowerThan5_13() {
			if coll, err := dualengine.LoadKmeshCgroupSockWorkloadCompat(); err != nil {
				return nil, fmt.Errorf("load Compat KmeshCgroupSockWorkloadCompat spec: %w", err)
			} else {
				specs["KmeshCgroupSockWorkloadCompat"] = coll.Maps
			}
		} else {
			if coll, err := dualengine.LoadKmeshCgroupSockWorkload(); err != nil {
				return nil, fmt.Errorf("load KmeshCgroupSockWorkload spec: %w", err)
			} else {
				specs["KmeshCgroupSockWorkload"] = coll.Maps
			}
		}
		// Symbol KmeshSendmsg has both normal and compat variants (dualengine).
		if helper.KernelVersionLowerThan5_13() {
			if coll, err := dualengine.LoadKmeshSendmsgCompat(); err != nil {
				return nil, fmt.Errorf("load Compat KmeshSendmsgCompat spec: %w", err)
			} else {
				specs["KmeshSendmsgCompat"] = coll.Maps
			}
		} else {
			if coll, err := dualengine.LoadKmeshSendmsg(); err != nil {
				return nil, fmt.Errorf("load KmeshSendmsg spec: %w", err)
			} else {
				specs["KmeshSendmsg"] = coll.Maps
			}
		}
		// Symbol KmeshSockopsWorkload has both normal and compat variants (dualengine).
		if helper.KernelVersionLowerThan5_13() {
			if coll, err := dualengine.LoadKmeshSockopsWorkloadCompat(); err != nil {
				return nil, fmt.Errorf("load Compat KmeshSockopsWorkloadCompat spec: %w", err)
			} else {
				specs["KmeshSockopsWorkloadCompat"] = coll.Maps
			}
		} else {
			if coll, err := dualengine.LoadKmeshSockopsWorkload(); err != nil {
				return nil, fmt.Errorf("load KmeshSockopsWorkload spec: %w", err)
			} else {
				specs["KmeshSockopsWorkload"] = coll.Maps
			}
		}
		// Symbol KmeshXDPAuth has both normal and compat variants (dualengine).
		if helper.KernelVersionLowerThan5_13() {
			if coll, err := dualengine.LoadKmeshXDPAuthCompat(); err != nil {
				return nil, fmt.Errorf("load Compat KmeshXDPAuthCompat spec: %w", err)
			} else {
				specs["KmeshXDPAuthCompat"] = coll.Maps
			}
		} else {
			if coll, err := dualengine.LoadKmeshXDPAuth(); err != nil {
				return nil, fmt.Errorf("load KmeshXDPAuth spec: %w", err)
			} else {
				specs["KmeshXDPAuth"] = coll.Maps
			}
		}
	}
	// General Symbol KmeshTcMarkDecrypt has normal+compat (choose by kernel)
	if helper.KernelVersionLowerThan5_13() {
		if coll, err := general.LoadKmeshTcMarkDecryptCompat(); err != nil {
			return nil, fmt.Errorf("load Compat KmeshTcMarkDecryptCompat spec: %w", err)
		} else {
			specs["KmeshTcMarkDecryptCompat"] = coll.Maps
		}
	} else {
		if coll, err := general.LoadKmeshTcMarkDecrypt(); err != nil {
			return nil, fmt.Errorf("load KmeshTcMarkDecrypt spec: %w", err)
		} else {
			specs["KmeshTcMarkDecrypt"] = coll.Maps
		}
	}
	// General Symbol KmeshTcMarkEncrypt has normal+compat (choose by kernel)
	if helper.KernelVersionLowerThan5_13() {
		if coll, err := general.LoadKmeshTcMarkEncryptCompat(); err != nil {
			return nil, fmt.Errorf("load Compat KmeshTcMarkEncryptCompat spec: %w", err)
		} else {
			specs["KmeshTcMarkEncryptCompat"] = coll.Maps
		}
	} else {
		if coll, err := general.LoadKmeshTcMarkEncrypt(); err != nil {
			return nil, fmt.Errorf("load KmeshTcMarkEncrypt spec: %w", err)
		} else {
			specs["KmeshTcMarkEncrypt"] = coll.Maps
		}
	}

	return specs, nil
}
